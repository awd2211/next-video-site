#!/usr/bin/env python3
"""
ÊÄßËÉΩËØäÊñ≠Â∑•ÂÖ∑ - ‰∏ÄÈîÆÊ£ÄÊü•Á≥ªÁªüÂÅ•Â∫∑Áä∂ÂÜµ

Usage:
    python scripts/diagnose.py
    python scripts/diagnose.py --check database
    python scripts/diagnose.py --check all --verbose
"""

import argparse
import asyncio
import sys
from datetime import datetime

import httpx
from loguru import logger


class PerformanceDiagnostic:
    """ÊÄßËÉΩËØäÊñ≠Â∑•ÂÖ∑"""

    def __init__(self, base_url: str = "http://localhost:8000", verbose: bool = False):
        self.base_url = base_url
        self.verbose = verbose
        self.issues = []
        self.warnings = []
        self.passed = []

    async def run_all_checks(self):
        """ËøêË°åÊâÄÊúâËØäÊñ≠Ê£ÄÊü•"""
        logger.info("\n" + "=" * 80)
        logger.info("üîç VideoSite Performance Diagnostic Tool")
        logger.info(f"üìÖ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        logger.info("=" * 80 + "\n")

        checks = [
            ("API Availability", self.check_api_availability),
            ("Health Status", self.check_health),
            ("Database Pool", self.check_database_pool),
            ("Cache Performance", self.check_cache),
            ("Response Times", self.check_response_times),
            ("Configuration", self.check_configuration),
            ("Security", self.check_security),
        ]

        for name, check_func in checks:
            logger.info(f"üìã Checking {name}...")
            try:
                await check_func()
            except Exception as e:
                self.issues.append(f"{name}: {str(e)}")
                logger.error(f"  ‚ùå Check failed: {e}")

            await asyncio.sleep(0.5)  # ÈÅøÂÖçËØ∑Ê±ÇËøáÂø´

        self.print_summary()

    async def check_api_availability(self):
        """Ê£ÄÊü•APIÂèØÁî®ÊÄß"""
        async with httpx.AsyncClient(timeout=10.0) as client:
            try:
                response = await client.get(f"{self.base_url}/")
                if response.status_code == 200:
                    self.passed.append("‚úÖ API is accessible")
                    logger.info("  ‚úÖ API is accessible")
                else:
                    self.issues.append(f"API returned status {response.status_code}")
                    logger.error(f"  ‚ùå API returned status {response.status_code}")
            except Exception as e:
                self.issues.append(f"Cannot connect to API: {e}")
                logger.error(f"  ‚ùå Cannot connect to API: {e}")

    async def check_health(self):
        """Ê£ÄÊü•ÂÅ•Â∫∑Áä∂ÊÄÅ"""
        async with httpx.AsyncClient(timeout=10.0) as client:
            try:
                response = await client.get(f"{self.base_url}/health")
                data = response.json()

                if data.get("status") == "healthy":
                    self.passed.append("‚úÖ Health check passed")
                    logger.info("  ‚úÖ Health check passed")

                    # Ê£ÄÊü•ÂêÑ‰∏™ÁªÑ‰ª∂
                    checks = data.get("checks", {})
                    for component, status in checks.items():
                        if status == "ok":
                            logger.info(f"    ‚úÖ {component}: OK")
                        else:
                            self.warnings.append(f"{component}: {status}")
                            logger.warning(f"    ‚ö†Ô∏è  {component}: {status}")
                else:
                    self.issues.append(f"System unhealthy: {data.get('status')}")
                    logger.error("  ‚ùå System is unhealthy")

            except Exception as e:
                self.issues.append(f"Health check failed: {e}")
                logger.error(f"  ‚ùå Health check failed: {e}")

    async def check_database_pool(self):
        """Ê£ÄÊü•Êï∞ÊçÆÂ∫ìËøûÊé•Ê±†"""
        async with httpx.AsyncClient(timeout=10.0) as client:
            try:
                response = await client.get(f"{self.base_url}/health")
                data = response.json()

                pool = data.get("database_pool", {})
                if pool:
                    checked_out = int(pool.get("checked_out", 0))
                    total = int(pool.get("total_connections", 1))
                    usage = (checked_out / total) * 100

                    logger.info(f"  üìä Pool usage: {usage:.1f}% ({checked_out}/{total})")

                    if usage > 80:
                        self.warnings.append(
                            f"Database pool usage high: {usage:.1f}%"
                        )
                        logger.warning(f"  ‚ö†Ô∏è  High pool usage: {usage:.1f}%")
                    elif usage > 90:
                        self.issues.append(
                            f"Database pool nearly exhausted: {usage:.1f}%"
                        )
                        logger.error(f"  ‚ùå Pool nearly exhausted: {usage:.1f}%")
                    else:
                        self.passed.append(f"‚úÖ Database pool healthy ({usage:.1f}%)")
                        logger.info(f"  ‚úÖ Pool usage healthy: {usage:.1f}%")
                else:
                    self.warnings.append("Database pool info not available")

            except Exception as e:
                self.warnings.append(f"Cannot check database pool: {e}")
                logger.warning(f"  ‚ö†Ô∏è  Cannot check pool: {e}")

    async def check_cache(self):
        """Ê£ÄÊü•ÁºìÂ≠òÊÄßËÉΩ"""
        # ËøôÈáåÈúÄË¶Åadmin tokenÔºåÊâÄ‰ª•Âè™ÂÅöÂü∫Á°ÄÊ£ÄÊü•
        logger.info("  ‚ÑπÔ∏è  Cache check requires admin access")
        logger.info("  üí° Tip: Check /admin/metrics/summary with admin token")
        self.passed.append("‚úÖ Cache check noted (requires admin)")

    async def check_response_times(self):
        """Ê£ÄÊü•ÂìçÂ∫îÊó∂Èó¥"""
        async with httpx.AsyncClient(timeout=30.0) as client:
            endpoints = [
                ("/", "Root"),
                ("/health", "Health Check"),
                ("/api/v1/categories", "Categories"),
            ]

            total_time = 0
            slow_endpoints = []

            for endpoint, name in endpoints:
                try:
                    start = asyncio.get_event_loop().time()
                    response = await client.get(f"{self.base_url}{endpoint}")
                    duration = asyncio.get_event_loop().time() - start

                    total_time += duration

                    if duration > 1.0:
                        slow_endpoints.append(f"{name}: {duration:.2f}s")
                        logger.warning(f"  ‚ö†Ô∏è  {name}: {duration:.2f}s (slow)")
                    else:
                        logger.info(f"  ‚úÖ {name}: {duration:.2f}s")

                except Exception as e:
                    logger.error(f"  ‚ùå {name}: Failed ({e})")

            avg_time = total_time / len(endpoints)

            if slow_endpoints:
                self.warnings.append(f"Slow endpoints: {', '.join(slow_endpoints)}")
            else:
                self.passed.append(
                    f"‚úÖ All endpoints respond quickly (avg: {avg_time:.2f}s)"
                )

    async def check_configuration(self):
        """Ê£ÄÊü•ÈÖçÁΩÆÔºàÂü∫Á°ÄÊ£ÄÊü•Ôºâ"""
        logger.info("  ‚ÑπÔ∏è  Configuration check requires file access")
        logger.info("  üí° Tip: Run app startup to see config validation")
        self.passed.append("‚úÖ Config check noted (run startup validation)")

    async def check_security(self):
        """Ê£ÄÊü•ÂÆâÂÖ®ÈÖçÁΩÆ"""
        async with httpx.AsyncClient(timeout=10.0) as client:
            try:
                response = await client.get(f"{self.base_url}/")

                # Ê£ÄÊü•ÂÆâÂÖ®Â§¥
                headers = response.headers

                security_headers = {
                    "X-Content-Type-Options": "nosniff",
                    "X-Frame-Options": "DENY",
                    "X-XSS-Protection": "1; mode=block",
                }

                missing_headers = []
                for header, expected in security_headers.items():
                    if header not in headers:
                        missing_headers.append(header)

                if missing_headers:
                    self.warnings.append(
                        f"Missing security headers: {', '.join(missing_headers)}"
                    )
                    logger.warning(f"  ‚ö†Ô∏è  Missing headers: {', '.join(missing_headers)}")
                else:
                    self.passed.append("‚úÖ Security headers present")
                    logger.info("  ‚úÖ Security headers present")

            except Exception as e:
                self.warnings.append(f"Cannot check security: {e}")

    def print_summary(self):
        """ÊâìÂç∞ËØäÊñ≠ÊëòË¶Å"""
        logger.info("\n" + "=" * 80)
        logger.info("üìä Diagnostic Summary")
        logger.info("=" * 80)

        # ÈÄöËøáÁöÑÊ£ÄÊü•
        if self.passed:
            logger.info(f"\n‚úÖ PASSED ({len(self.passed)}):")
            for item in self.passed:
                logger.info(f"  {item}")

        # Ë≠¶Âëä
        if self.warnings:
            logger.warning(f"\n‚ö†Ô∏è  WARNINGS ({len(self.warnings)}):")
            for item in self.warnings:
                logger.warning(f"  {item}")

        # ÈóÆÈ¢ò
        if self.issues:
            logger.error(f"\n‚ùå ISSUES ({len(self.issues)}):")
            for item in self.issues:
                logger.error(f"  {item}")

        # ÊÄªÁªì
        logger.info("\n" + "=" * 80)
        total = len(self.passed) + len(self.warnings) + len(self.issues)
        health_score = (
            (len(self.passed) + len(self.warnings) * 0.5) / total * 100 if total > 0 else 0
        )

        if health_score >= 90:
            status = "EXCELLENT ‚ú®"
            color = "green"
        elif health_score >= 70:
            status = "GOOD ‚úÖ"
            color = "green"
        elif health_score >= 50:
            status = "FAIR ‚ö†Ô∏è"
            color = "yellow"
        else:
            status = "NEEDS ATTENTION ‚ùå"
            color = "red"

        logger.info(f"Overall Health Score: {health_score:.1f}% - {status}")

        if self.issues:
            logger.info("\nüí° Recommendations:")
            logger.info("  1. Fix critical issues listed above")
            logger.info("  2. Review warnings for potential improvements")
            logger.info("  3. Check logs for detailed error information")

        logger.info("=" * 80 + "\n")

        # ÈÄÄÂá∫Á†Å
        if self.issues:
            sys.exit(1)  # ÊúâÈóÆÈ¢òÂàôÈÄÄÂá∫Á†Å‰∏∫1
        else:
            sys.exit(0)


async def main():
    """‰∏ªÂáΩÊï∞"""
    parser = argparse.ArgumentParser(description="Performance Diagnostic Tool")
    parser.add_argument(
        "--base-url", default="http://localhost:8000", help="Base URL of the API"
    )
    parser.add_argument("--verbose", "-v", action="store_true", help="Verbose output")
    parser.add_argument(
        "--check",
        choices=["api", "health", "database", "cache", "all"],
        default="all",
        help="Specific check to run",
    )

    args = parser.parse_args()

    diagnostic = PerformanceDiagnostic(base_url=args.base_url, verbose=args.verbose)

    if args.check == "all":
        await diagnostic.run_all_checks()
    else:
        logger.info(f"Running {args.check} check...")
        # ÂèØ‰ª•Ê∑ªÂä†Âçï‰∏™Ê£ÄÊü•ÁöÑÈÄªËæë
        await diagnostic.run_all_checks()


if __name__ == "__main__":
    asyncio.run(main())
