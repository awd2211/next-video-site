/**
 * WebSocket Context for Global Notification Management
 * å…¨å±€WebSocketä¸Šä¸‹æ–‡,æä¾›å®æ—¶é€šçŸ¥åŠŸèƒ½
 */
import { createContext, useContext, useState, ReactNode } from 'react'
import { useWebSocket, TranscodeProgressMessage, TranscodeCompleteMessage, TranscodeFailedMessage } from '@/hooks/useWebSocket'
import { notification } from 'antd'
import { SyncOutlined, CheckCircleOutlined, CloseCircleOutlined, BellOutlined, WarningOutlined, InfoCircleOutlined } from '@ant-design/icons'
import { useQueryClient } from '@tanstack/react-query'

interface WebSocketContextValue {
  isConnected: boolean
  unreadCount: number
  transcodeProgress: Map<number, TranscodeProgressMessage>
  markAsRead: () => void
  adminUnreadCount: number
}

const WebSocketContext = createContext<WebSocketContextValue | undefined>(undefined)

export function useWebSocketContext() {
  const context = useContext(WebSocketContext)
  if (!context) {
    throw new Error('useWebSocketContext must be used within WebSocketProvider')
  }
  return context
}

interface WebSocketProviderProps {
  children: ReactNode
}

export function WebSocketProvider({ children }: WebSocketProviderProps) {
  const queryClient = useQueryClient()
  const [unreadCount, setUnreadCount] = useState(0)
  const [adminUnreadCount, setAdminUnreadCount] = useState(0)
  const [transcodeProgress, setTranscodeProgress] = useState<Map<number, TranscodeProgressMessage>>(new Map())

  // å¤„ç†ç®¡ç†å‘˜é€šçŸ¥
  const handleAdminNotification = (message: any) => {
    console.log('ğŸ“¢ æ”¶åˆ°ç®¡ç†å‘˜é€šçŸ¥:', message)

    // å¢åŠ æœªè¯»è®¡æ•°
    setAdminUnreadCount((prev) => prev + 1)

    // åˆ·æ–°é€šçŸ¥åˆ—è¡¨
    queryClient.invalidateQueries({ queryKey: ['adminNotifications'] })
    queryClient.invalidateQueries({ queryKey: ['adminNotificationStats'] })

    // æ ¹æ®ä¸¥é‡ç¨‹åº¦æ˜¾ç¤ºä¸åŒçš„é€šçŸ¥
    const notificationConfig: any = {
      message: message.title || 'æ–°é€šçŸ¥',
      description: message.content,
      duration: message.severity === 'critical' || message.severity === 'error' ? 0 : 5,
      onClick: () => {
        // å¯ä»¥å®ç°ç‚¹å‡»è·³è½¬
        if (message.link) {
          window.location.href = message.link
        }
      },
    }

    switch (message.severity) {
      case 'critical':
      case 'error':
        notification.error({
          ...notificationConfig,
          icon: <CloseCircleOutlined style={{ color: '#ff4d4f' }} />,
        })
        break
      case 'warning':
        notification.warning({
          ...notificationConfig,
          icon: <WarningOutlined style={{ color: '#faad14' }} />,
        })
        break
      case 'info':
      default:
        notification.info({
          ...notificationConfig,
          icon: <BellOutlined style={{ color: '#1890ff' }} />,
        })
        break
    }
  }

  // è½¬ç è¿›åº¦æ›´æ–°
  const handleTranscodeProgress = (message: TranscodeProgressMessage) => {
    setTranscodeProgress((prev) => {
      const newMap = new Map(prev)
      newMap.set(message.video_id, message)
      return newMap
    })

    // å¦‚æœæ˜¯å¼€å§‹è½¬ç ,æ˜¾ç¤ºé€šçŸ¥
    if (message.progress === 0) {
      notification.info({
        message: 'å¼€å§‹è½¬ç ',
        description: message.message || `è§†é¢‘ID: ${message.video_id}`,
        icon: <SyncOutlined spin style={{ color: '#1890ff' }} />,
        duration: 3,
      })
      setUnreadCount((prev) => prev + 1)
    }
  }

  // è½¬ç å®Œæˆ
  const handleTranscodeComplete = (message: TranscodeCompleteMessage) => {
    // ä»è¿›åº¦ä¸­ç§»é™¤
    setTranscodeProgress((prev) => {
      const newMap = new Map(prev)
      newMap.delete(message.video_id)
      return newMap
    })

    notification.success({
      message: 'è½¬ç å®Œæˆ',
      description: (
        <div>
          <div><strong>{message.title}</strong></div>
          <div>æ ¼å¼: {message.format_type.toUpperCase()}</div>
          <div>å¤§å°: {formatFileSize(message.file_size)}</div>
        </div>
      ),
      icon: <CheckCircleOutlined style={{ color: '#52c41a' }} />,
      duration: 5,
    })
    setUnreadCount((prev) => prev + 1)
  }

  // è½¬ç å¤±è´¥
  const handleTranscodeFailed = (message: TranscodeFailedMessage) => {
    // ä»è¿›åº¦ä¸­ç§»é™¤
    setTranscodeProgress((prev) => {
      const newMap = new Map(prev)
      newMap.delete(message.video_id)
      return newMap
    })

    notification.error({
      message: 'è½¬ç å¤±è´¥',
      description: (
        <div>
          <div><strong>{message.title}</strong></div>
          <div style={{ color: '#ff4d4f', fontSize: '12px' }}>
            {message.error.substring(0, 100)}...
          </div>
        </div>
      ),
      icon: <CloseCircleOutlined style={{ color: '#ff4d4f' }} />,
      duration: 0, // å¤±è´¥æ¶ˆæ¯ä¸è‡ªåŠ¨å…³é—­
    })
    setUnreadCount((prev) => prev + 1)
  }

  // æ ‡è®°ä¸ºå·²è¯»
  const markAsRead = () => {
    setUnreadCount(0)
  }

  const { isConnected } = useWebSocket(true, {
    autoConnect: true,
    autoReconnect: true,
    onTranscodeProgress: handleTranscodeProgress,
    onTranscodeComplete: handleTranscodeComplete,
    onTranscodeFailed: handleTranscodeFailed,
    onMessage: (message) => {
      // å¤„ç†æ‰€æœ‰æ¶ˆæ¯ç±»å‹
      if (message.type === 'admin_notification') {
        handleAdminNotification(message)
      }
    },
    onConnect: () => {
      console.log('âœ… WebSocketå·²è¿æ¥')
    },
    onDisconnect: () => {
      console.log('âŒ WebSocketå·²æ–­å¼€')
    },
  })

  return (
    <WebSocketContext.Provider
      value={{
        isConnected,
        unreadCount,
        transcodeProgress,
        markAsRead,
        adminUnreadCount,
      }}
    >
      {children}
    </WebSocketContext.Provider>
  )
}

/**
 * æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
 */
function formatFileSize(bytes: number): string {
  if (bytes === 0) return '0 B'

  const k = 1024
  const sizes = ['B', 'KB', 'MB', 'GB', 'TB']
  const i = Math.floor(Math.log(bytes) / Math.log(k))

  return Math.round((bytes / Math.pow(k, i)) * 100) / 100 + ' ' + sizes[i]
}
